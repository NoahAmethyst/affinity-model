### 一、总体流程
通过 `cal_affinity()` 方法计算两类亲和性：
1. **Pod间亲和性**（`pod_affinity`）：综合网络、指挥、资源竞争三类关系
2. **节点亲和性**（`node_affinity`）：判断Pod与节点的资源匹配性

---

### 二、Pod间亲和性计算
#### 1. **网络亲和性** (`net_affinity`)
- **计算逻辑**：  
  对每对Pod间的边，计算 `net_affinity = 通信频率(freq) × 数据包大小(package)`
    - 值越大表示网络通信需求越高
- **物理意义**：  
  频繁通信的Pod应优先部署在同一节点

#### 2. **指挥亲和性** (`command_affinity`)
- **计算逻辑**：
    1. 通过指挥关系图 (`command_graph`) 计算两Pod所属平台的最短路径长度
    2. 亲和性值为路径长度的倒数：`command_affinity = 1 / path_length`
        - 路径越短，指挥关系越紧密（值越大）
- **特殊处理**：  
  若路径长度为0（同一平台），设为0.1避免除零

#### 3. **资源竞争亲和性** (`race_affinity`)
- **计算逻辑**：  
  调用 `BasePod.race_affinity()` 计算两Pod的资源竞争强度，取负值：`race_affinity = -竞争值`
    - 竞争越激烈，负值越大（表示应避免部署在一起）

#### 4. **综合加权计算** (`pod_affinity_to_matrix`)
- **输入参数**：
    - `attr`: 需聚合的属性名（如 `['net_affinity', 'command_affinity', 'race_affinity']`）
    - `weight`: 对应属性的权重列表
- **处理步骤**：
    1. 为每个属性生成独立矩阵，并归一化（若 `norm=True`）
    2. 按权重叠加所有属性矩阵
    3. 对结果二次归一化，确保最终值在 `[0, 1]` 范围内
- **输出**：  
  对称矩阵，表示所有Pod间的综合亲和性（值越大表示越应靠近部署）

---

### 三、节点亲和性计算 (`node_affinity`)
- **计算逻辑**：  
  生成 `Pod数 × 节点数` 的0-1矩阵，判断Pod是否适合部署到节点：
  ```python
  matrix[x, y] = 1 if node.resources >= pod.resources else 0
  ```
- **物理意义**：  
  仅当节点资源满足Pod需求时标记为1（硬性约束）

---

### 四、关键设计特点
1. **归一化处理**：
    - 所有属性矩阵和最终结果均被归一化到 `[0, 1]`，避免量纲差异
2. **对称性保证**：
    - Pod间亲和性矩阵始终对称（`matrix[i][j] = matrix[j][i]`）
3. **权重可控**：
    - 通过 `Graph.weight` 可调整不同亲和性类型的优先级

---

### 五、应用示例
假设权重配置为 `[0.6, 0.3, 0.1]`（网络 > 指挥 > 资源竞争），则最终亲和性偏向满足高频通信需求的Pod组合。调度器可结合 `pod_affinity` 和 `node_affinity` 矩阵，选择综合最优的部署方案。